#!/usr/bin/perl

=head1 NAME

gofer - execute multiple ssh sessions in parallel

=head1 SYNOPSIS

    # This uses the file hosts.conf to define thie configuration,
    # and then reads and executes the commands in cmdfile on each host.
    gofer --config hosts.conf  cmdfile.

    # This checks for .gofer.conf, $USER/.gofer.conf or
    # /etc/gofer.conf, and uses the first one available to define the
    # ssh connections, and then executes the commands defied in
    # cmdfile on each host.  If this or the connections config is not
    # found, it will exit with an error.
    gofer cmdfile  

=head1 DESCRIPTION

This script will log in and execute commands on remote ssh servers.

It is WORK-IN-PROGRESS!  Expect rough edges.

=head1 CONNECTIONS DEFINITIONS

An example connections configuration file.

    # It can contain comments and blank lines
    host1   @host1

    host2   user2@host2
    host3   user3:password3@host3
    host4   user4@host4:873
    host5   user5:password5@host5:873

=head1 CMDFILE

An example command file:

    # It can contain comments and blank lines

    # normal commands are executed as the user logged in
    ls 

    # Multiple commands can be combined
    cd / ; ls
    grep /etc/hosts | cat >file

    # If the line starts with "sudo" then the rest of the line
    # is executed within a sudo shell
    sudo cd /root/configuration; git status

    # All commands are run under /bin/sh, which must be present for
    # things to work


=head1 EXAMPLE OUTPUT

An example showing what you might get invoking:

    cat hosts | gofer git-status.sh

With C<git-status.sh> containing:

   # bla de bla

   sudo cd /root/configuration; git status

And a C<hosts> containing:

    alpha    @alpha
    beta     @beta

Then you might get output like the following:
 

    ----[ alpha ]-----------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch WORK_IN_PROGRESS
    nothing to commit (working directory clean)

    ----(4s elapsed)

    ----[ beta ]------------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch BETA_LOCAL_MODS
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #
    #	modified:   foo/src/stuff.h
    #
    no changes added to commit (use "git add" and/or "git commit -a")

    ----(4s elapsed)

    done

=cut

use strict;
use warnings;
use Getopt::Long qw(:config gnu_compat);
use IO::File;
use List::Util qw(first);
use FindBin '$Bin';
use lib "$Bin/../local-lib/lib/perl5", "$Bin/../local-lib/lib/perl5/i486-linux-gnu-thread-multi", 
    "$Bin/../lib";

use Carp qw(croak);

######################################################################

sub slurp {
    my ($file) = @_;
    my $fh = IO::File->new($file)
        or croak "failed to open $file: $!";
    local $/;
    return <$fh>;
}


# Prompt for a password, and read it directly from terminal (so that
# we can also read from stdin).  This won't work on non-unix systems,
# since they don't have /dev/tty.  I'm not sure what I should do
# there, presumably use Win32::Console?
# Adapted from
# http://perldoc.perl.org/perlfaq5.html#How-can-I-read-a-single-character-from-a-file?--From-the-keyboard?
# And http://www.perlmonks.org/?node_id=773803
sub prompt {
    my ($prompt) = @_;
    my $phrase = '';

    open my $tty, '<', '/dev/tty';
    local $| = 1;
    print $prompt;

    Term::ReadKey::ReadMode('noecho', $tty);

    while (1) {
        my $c = Term::ReadKey::ReadKey(~0/2-1, $tty); 
        # Windows workaround http://rt.cpan.org/Public/Bug/Display.html?id=27944

        if ($c =~ /[\r\n]/) {
            print "\n";
            last;
        }
        elsif ($c eq "\b" || ord $c == 127) {
            next unless length $phrase;
            chop $phrase;
        }
        elsif (ord $c) {
            $phrase .= $c;
        }
    }
    Term::ReadKey::ReadMode('restore', $tty);
    return $phrase;
}


# Stolen from Net::OpenSSH
my $obfuscate = sub {
    # just for the casual observer...
    my $txt = shift;
    $txt =~ s/(.)/chr(ord($1) ^ 47)/ges
        if defined $txt;
    $txt;
};
my $deobfuscate = $obfuscate;


# Constructors for the various password broker functions
my %password_brokers = (
    # Just interprets the token as the password in plaintext.
    # Maximally insecure.
    plaintext => sub { 
        return sub { shift },
    },

    # Interpret the token as a password obfuscated using $obfuscate
    obfuscated => sub { $deobfuscate },

    # Uses the token as a name to prompt the user for the *real* password.
    prompt => sub {
        require Term::ReadKey; # We must have this loaded.

        # keep the passwords here
        my %password_cache;

        return sub {
            my $token = shift;

            if (defined $password_cache{$token}) {
                return $password_cache{$token};
            }

            my $password = prompt "password for $token: ", echo => '*';

            return $password_cache{$token} = $password;
        };
    },
);



# Split a string created by serialise_line into a name and an
# attribute-value list. Note, this function should *not* leak sensitive
# information, yet alone include passwords in error messages!
#
# Adapted from Cluster::Facts to avoid a dependency.
use Text::ParseWords qw(parse_line);
sub deserialize {
    my $line = shift;
    my ($empty, $name, @values) = parse_line qr/\s*(=\s*|\s+)/, 0, $line;

    # Perform some sanity checking
    die "line does not start with '='\n"
        if length $empty;

    die "number of attribute values does not match number of keys"
        if @values % 2;

    # Count each key's frequency whilst converting to a hash
    my %counts;
    my %attrs = map {
        $counts{$values[0]}++;
        splice @values, 0 ,2;
    } 1..@values/2;

    # collect (quoted) names of duplicates
    my @duplicates = map {
        s/'/\\'/g; 
        "'$_'";
    } grep {
        $counts{$_} > 1;
    } keys %counts;
    
    die "duplicated keys\n"
        if @duplicates;

    return $name, \%attrs;
}


=head2 parse_map %options

Parses a sequence of lines of the following form:

    C<host   user:password@host:port>

Returns an array of C<<($name => \%params)>> pairs, each defining a
connection name and a parameter hash as accepted by
C<<Net::SSH::Mechanize::ConnectParams->new>>, which can be passed
directly to C<<Net::SSH::Mechanize::Multi->add>>.

=cut

sub parse_map {
    my %params = @_;
    my $password_broker = $params{password_broker};
    my $credentials = $params{credentials};
    my $passwords_required = $params{passwords_required};

    my @map;
    my $line_no = 0;
    foreach my $str (@$credentials) {
        foreach (split '\n', $str) {
            ++$line_no;
            next if /^\s*#/;
            next if /^\s*$/;

            my ($name, $attrs) = eval {
                deserialize $_;
            }
            or do {
                # Note: deserialize should be written to not divulge anything
                # specific, just a type of error.
                die "error parsing credentials, on line #$line_no: $@\n";
            };

            my $authentication = $attrs->{authentication} || '';
            if ($passwords_required || $authentication eq 'password') {
                # Obtain the real password from our broker, if one exists.
                # This allows us to perform whatever sort of prompting,
                # look-up, or decryption we need, in a customisable way.

                my $identifier = $attrs->{password} || $name;
                $attrs->{password} = $password_broker->($identifier);
            }
            else {
                # Remove password, to avoid distributing it unnecessarily
                delete $attrs->{password};
            }

            # A convenience.
            $attrs->{host} ||= $name;
            
            push @map, $name, $attrs;
        }
    }
    

    return @map;
}


sub compile_script {
    my $sudos = 0;
    my @steps;

    foreach my $str (@_) {
        foreach (split '\n', $str) {
            my $line = $_;
            if (/^\s*#/ || /^\s*$/) {
                push @steps, sub { "  $line\n" };
                next;
            }

            chomp;
            if (s/^\s*sudo\s*//) {
                
                push @steps, sub { qq(  \$ sudo "$line"\n) };

                push @steps, sub { 
                    my $result = shift->sudo_capture($line);
                    return "$result\n"
                        if $result;
                };

                $sudos++;
            }
            else {
                push @steps, sub { qq(  \$ $line\n) };
                push @steps, sub {
                    my $result = shift->capture($line);

                    return "$result\n"
                        if $result;
                };
            }
        }
    }
    my $compiled = sub {
        my $ssh = shift;
        my @results;
        eval {
            foreach my $step (@steps) {
                push @results, $step->($ssh);
            }
            1;
        }
        or do {
            push @results, "$@"; 
        };
        return \@results;
    };

    return ($compiled, $sudos);
}


######################################################################

my $commands;
my $command_file;
my @credentials;
my $no_op;
my $password_broker = 'prompt';
GetOptions(
    "--no-op" => \$no_op,
    "--file=s" => sub {
        # FIXME can this be called twice?
        die "can't specify both --command and --file\n"
            if $commands;

        (undef, $command_file) = @_;
        die "no such file '$command_file'\n"
            unless -f $command_file;

        $commands = slurp $command_file;
    },
    "--password=s" => sub {
        (undef, $password_broker) = @_;
        die "No such password broker '$password_broker'\n"
            unless $password_brokers{$password_broker};
    },
    "--credentials=s" => sub {
        my (undef, $credentials_file) = @_;
        die "no such file '$credentials_file'\n"
            unless -f $credentials_file;

        @credentials = slurp $credentials_file;
    },
)
    or die "failed to parse options, stopping\n";

if ($command_file && @ARGV) {
    die "can't accept arguments if --file is given\n"
}
else {
    $commands = join " ", @ARGV;
}


# Construct the password broker.  This should generate an error if
# there is any problem.
$password_broker = $password_brokers{$password_broker}->();

die "Please supply some commands\n"
    unless $commands 
        && $commands =~ /\S/;

if ($no_op) {
    # just print the command.
    # FIXME print the hosts too?
    print "$commands\n";
    exit 0;
}

# Get credentials from STDIN if none already read
@credentials
    or @credentials = <STDIN>;

# Compile the commands, find out if we need to prompt for passwords
my ($script, $sudos) = compile_script $commands;

# Parse the credentials, get passwords if required
my %map = parse_map(
    password_broker => $password_broker,
    prompt_always => $sudos,
    credentials => \@credentials,
);


# This module uses Moose and is a bit slow to start; don't start it
# unless we get this far.
require Net::SSH::Mechanize::Multi;

my $manager = Net::SSH::Mechanize::Multi->new;
$manager->add(%map);

my $threads = $manager->in_parallel(keys %map => sub {
    my ($name, $ssh) = @_;
    my $start = time;

    my $results = $script->($ssh);

    print "----[ $name ]", '-'x(64 - length $name), "\n";
    print @$results;
    my $elapsed = time - $start;
    print "----(${elapsed}s elapsed)\n\n";
});

$_->join for @$threads;

print "done\n";
